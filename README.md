# Market data contribution gateway

This is an implementation of a Market Data Gateway REST API written in C#.

I've taken a TDD approach to developing this including using integration tests to ensure the REST API endpoints are
properly covered from the point of view of how they will actually be used - i.e. via HTTP requests potentially with JSON
bodies.

## Assumptions and limitations

1. Only contributions that pass validation are stored.
2. Validation responses from the market data validator can be mapped to an `enum`.
3. Data storage is strictly in-memory for simplicity's sake.
4. The reference used to return a market data contribution after it has been added is a reference generated by the API when the data is added.
I pondered having the user supply a unique reference but that places burden on the end user to come up with something globally unique.
5. The market data validator is simulated to just check (a) if what it receives is recognised (i.e. a FxQuote) and (b) that the FxQuote bis and ask are sane.
6. I've assumed that some simple validation is appropriate in the gateway - for instance that currency codes are 3 letters long etc.
The market validator would presumably also do that but it would seem better to screen for obvious bad data that requires little domain knowledge as early as possible.

## REST API

The REST API has two endpoints.

### New market data contribution request

To make a new contribution:

`POST /marketdata`

with JSON content specifying the data:

```json
{
  "marketDataType": "FxQuote",
  "timestamp": "2023-02-18T17:32:05.606Z",
  "bid": 2.5,
  "ask": 2.6,
  "currencyPair": "GBP/USD"
}
```

Note that the `marketDataType` field must be first in the JSON object.
Currently only `FxQuote` is supported.
The response will be a JSON object like:

```json
{
  "reference": "865d5798911d424a85c572a8ba29fac6",
  "statusCode": "Ok"
}
```

where status would be either `Ok` or an error code returned by the market data validator.
If an error status code is returned then no reference will be present as nothing will have been stored.

### Get market data

To get market data:

`GET /marketdata/{marketDataReference}`

For example: `GET /marketdata/865d5798911d424a85c572a8ba29fac6`

The response will be a JSON object like:

```json
{
  "marketDataType": "FxQuote",
  "timestamp": "2023-02-18T17:32:05.606Z",
  "bid": 2.5,
  "ask": 2.6,
  "currencyPair": "GBP/USD"
}
```

If the market data reference is unknown then a `404` will be returned.

## Building and running

The easiest way to build and run is to load the solution [MarketDataGateway.sln](MarketDataGateway.sln) in Rider or Visual
Studio and build and run from there.

Alternatively, the command line (assuming Linux) for building would be:

```bash
dotnet build ./MarketDataGateway.sln
```

and for running the tests:

```bash
dotnet test ./MarketDataGateway.sln
```

and finally to run the service:

```bash
MarketDataGateway/bin/Debug/net7.0/MarketDataGateway
```

This starts listening for requests on http://localhost:5000.
You can then either use a tool like Curl to hit the endpoints or use Swagger in a browser at http://localhost:5000/swagger/index.html.

## Containerisation

I've added containerisation support using docker.
To build run the following from the root of the solution:

```bash
docker build --tag mdgateway:1.0 ./
```

and then to run do

```bash
docker run -p 5000:80 mdgateway:1.0
```

This will expose the API to fielding requests on http://localhost:5000.
You can then either use a tool like Curl to hit the endpoints or use Swagger in a browser at http://localhost:5000/swagger/index.html.

## Improvements

### Security

This solution is utterly devoid of authentication or authorization mechanisms.
In a real-world project this would obviously be a primary concern and we'd want to enable ASP.NET's security features to
use HTTPS (including redirection) and to ensure that an external user is not only authenticated correctly but also has
the correct permissions to use particular endpoints.

### Database

Obviously the in-memory "database" used in this implementation is not production-worthy.
We need something with persistence.
Most likely this should be in a distributed relational database though the number of different market data types might make a simple solution difficult to achieve so possibly some NOSQL document store might be better, especially if new data types crop up frequently.
In addition, the volume of data could get large over time, especially if automated processes exist to add price data or similar.
As such potentially we'd need to make recent data more readily available than older data.

### Logging

There is no logging currently in the service, barring the default ASP.NET logging.
A good option might be to use Serilog to log structured logs to Logstash so the logs could be used in an ELK stack, for
instance.
